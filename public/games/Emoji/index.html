<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Emoji Memory Match</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      font-family: "Courier New", monospace;
      background: radial-gradient(circle at 20% 20%, #1f2b3a, #0c121a 60%);
      color: #e8f0ff;
    }
    .layout {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
    }
    .frame {
      width: min(520px, 92vw);
      text-align: center;
    }
    h1 {
      margin: 0 0 8px;
      letter-spacing: 2px;
      font-size: 26px;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.12);
    }
    .stats {
      display: flex;
      justify-content: center;
      gap: 14px;
      margin-bottom: 12px;
      font-size: 14px;
      color: #b8c7e0;
      flex-wrap: wrap;
    }
    #grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
    }
    .card {
      position: relative;
      width: 100%;
      aspect-ratio: 1 / 1;
      perspective: 800px;
      cursor: pointer;
    }
    .card.matched { cursor: default; }
    .inner {
      position: absolute;
      inset: 0;
      transition: transform 0.35s ease;
      transform-style: preserve-3d;
      border-radius: 12px;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
    }
    .card.flipped .inner { transform: rotateY(180deg); }
    .face {
      position: absolute;
      inset: 0;
      backface-visibility: hidden;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 34px;
    }
    .front {
      background: linear-gradient(145deg, #1a2430, #121a24);
      color: #e6f1ff;
      border: 1px solid #1e2b3a;
      text-shadow: 0 0 12px rgba(232, 240, 255, 0.25);
    }
    .back {
      background: linear-gradient(145deg, #38a3ff, #3973ff);
      color: #0c111a;
      border: 1px solid rgba(255, 255, 255, 0.12);
      transform: rotateY(180deg);
      font-size: 40px;
    }
    #overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, 0.65);
      backdrop-filter: blur(2px);
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.2s ease, visibility 0.2s ease;
    }
    #overlay.show {
      visibility: visible;
      opacity: 1;
    }
    .modal {
      background: #101722;
      border: 1px solid #223146;
      padding: 28px 32px;
      border-radius: 12px;
      text-align: center;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
    }
    .modal h2 {
      margin: 0 0 10px;
      letter-spacing: 1px;
      color: #7dd6ff;
    }
    button {
      margin-top: 12px;
      padding: 10px 16px;
      border: none;
      border-radius: 8px;
      font-family: "Courier New", monospace;
      background: linear-gradient(135deg, #4ef3c3, #4f8bff);
      color: #0c131d;
      cursor: pointer;
      box-shadow: 0 8px 20px rgba(79, 139, 255, 0.35);
      transition: transform 120ms ease, box-shadow 120ms ease;
    }
    button:hover { transform: translateY(-1px); box-shadow: 0 10px 22px rgba(79, 139, 255, 0.45); }
    button:active { transform: translateY(1px); }
    .side-info {
      max-width: 240px;
      color: #d9e7ff;
      font-size: 14px;
      line-height: 1.5;
      text-align: left;
    }
    .leaderboard {
      margin-top: 12px;
      padding: 10px;
      background: rgba(34, 49, 70, 0.55);
      border: 1px solid #223146;
      border-radius: 10px;
    }
    .leaderboard .label {
      text-transform: uppercase;
      font-size: 11px;
      letter-spacing: 1px;
      color: #9bb2d6;
      margin-bottom: 6px;
    }
    #leaderboard-list { margin: 0; padding-left: 18px; }
    #leaderboard-list li { margin-bottom: 4px; }
    #leaderboard-list li.empty {
      list-style: none;
      padding-left: 0;
      color: #9bb2d6;
    }
    .side-info .project {
      margin-top: 8px;
      color: #9bb2d6;
      font-size: 13px;
    }
    .menu-link {
      display: inline-block;
      margin-top: 12px;
      padding: 8px 12px;
      border-radius: 6px;
      background: #4ef3c3;
      color: #0c131d;
      text-decoration: none;
      font-weight: bold;
      box-shadow: 0 0 10px rgba(78, 243, 195, 0.4);
    }
  </style>
</head>
<body>
  <div class="layout">
    <div class="frame">
      <h1>Emoji Memory Match</h1>
      <div class="stats">
        <div>Time: <span id="time">0.0</span>s</div>
        <div>Matches: <span id="matches">0</span>/8</div>
        <div>Score: <span id="score">0</span></div>
        <div>Best: <span id="best">0</span></div>
      </div>
      <div id="grid"></div>
    </div>
    <div class="side-info">
      Flip two cards to find pairs. Matches stay face up; mismatches flip after a second. Clear all pairs as fast as you can!<br>
      <span class="project">Project of CCIS students</span>
      <div class="leaderboard">
        <div class="label">Leaderboard</div>
        <ol id="leaderboard-list"></ol>
      </div>
    </div>
  </div>

  <div id="overlay">
    <div class="modal">
      <h2>You Win!</h2>
      <p>Total Time: <span id="final-time">0.0</span>s</p>
      <p>Score: <span id="final-score">0</span></p>
      <button id="restart">Play Again</button>
    </div>
  </div>

  <script src="../leaderboard.js"></script>
  <script>
    const grid = document.getElementById("grid");
    const timeEl = document.getElementById("time");
    const matchesEl = document.getElementById("matches");
    const overlay = document.getElementById("overlay");
    const finalTimeEl = document.getElementById("final-time");
    const finalScoreEl = document.getElementById("final-score");
    const restartBtn = document.getElementById("restart");
    const scoreEl = document.getElementById("score");
    const bestEl = document.getElementById("best");
    const leaderboardListEl = document.getElementById("leaderboard-list");

    const emojiSet = ["ðŸš€","ðŸ±","ðŸ•","ðŸŒµ","âš½","ðŸ’Ž","ðŸŽ¸","ðŸŽˆ"];
    const leaderboard = createLeaderboard({
      storageKey: "emojiMemoryLeaderboard",
      nameKey: "emojiMemoryPlayerName",
      listElement: leaderboardListEl
    });
    let cards = [];
    let firstCard = null;
    let secondCard = null;
    let lockBoard = false;
    let matches = 0;
    let score = 0;
    let startTime = null;
    let timerId = null;

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function startTimer() {
      startTime = performance.now();
      timerId = setInterval(() => {
        const elapsed = (performance.now() - startTime) / 1000;
        timeEl.textContent = elapsed.toFixed(1);
      }, 100);
    }

    function stopTimer() {
      if (timerId) {
        clearInterval(timerId);
        timerId = null;
      }
    }

    function calculateScore(seconds) {
      return Math.max(0, Math.round(6000 / Math.max(1, seconds)));
    }

    function updateScoreDisplay() {
      scoreEl.textContent = score;
      bestEl.textContent = leaderboard.format(leaderboard.best());
      leaderboard.render();
    }

    function createCard(emoji) {
      const card = document.createElement("div");
      card.className = "card";
      card.dataset.emoji = emoji;

      const inner = document.createElement("div");
      inner.className = "inner";

      const front = document.createElement("div");
      front.className = "face front";
      front.textContent = "?";

      const back = document.createElement("div");
      back.className = "face back";
      back.textContent = emoji;

      inner.appendChild(back);
      inner.appendChild(front);
      card.appendChild(inner);
      card.addEventListener("click", onCardClick);
      return card;
    }

    function setupBoard() {
      grid.innerHTML = "";
      grid.style.gridTemplateColumns = "repeat(4, 1fr)";
      const deck = shuffle([...emojiSet, ...emojiSet]);
      cards = deck.map(createCard);
      cards.forEach(card => grid.appendChild(card));
    }

    function resetGame() {
      firstCard = null;
      secondCard = null;
      lockBoard = false;
      matches = 0;
      matchesEl.textContent = matches;
      score = 0;
      updateScoreDisplay();
      stopTimer();
      startTime = null;
      timeEl.textContent = "0.0";
      overlay.classList.remove("show");
      setupBoard();
    }

    function finishRun() {
      stopTimer();
      const elapsedSeconds = startTime ? (performance.now() - startTime) / 1000 : Number(timeEl.textContent) || 0;
      const runScore = calculateScore(elapsedSeconds || 0.1);
      score = runScore;
      finalTimeEl.textContent = elapsedSeconds.toFixed(1);
      finalScoreEl.textContent = runScore;
      overlay.classList.add("show");
      leaderboard.record(runScore);
      updateScoreDisplay();
      startTime = null;
    }

    function onCardClick(e) {
      const card = e.currentTarget;
      if (lockBoard || card.classList.contains("flipped") || card.classList.contains("matched")) return;
      if (!startTime) startTimer();

      flipCard(card);

      if (!firstCard) {
        firstCard = card;
        return;
      }

      secondCard = card;
      lockBoard = true;

      const match = firstCard.dataset.emoji === secondCard.dataset.emoji;
      if (match) handleMatch();
      else handleMismatch();
    }

    function flipCard(card) {
      card.classList.add("flipped");
    }

    function unflipCards() {
      setTimeout(() => {
        firstCard.classList.remove("flipped");
        secondCard.classList.remove("flipped");
        resetTurn();
      }, 1000);
    }

    function handleMatch() {
      firstCard.classList.add("matched");
      secondCard.classList.add("matched");
      matches++;
      matchesEl.textContent = matches;
      if (matches === emojiSet.length) {
        finishRun();
      }
      resetTurn();
    }

    function handleMismatch() {
      unflipCards();
    }

    function resetTurn() {
      [firstCard, secondCard] = [null, null];
      lockBoard = false;
    }

    restartBtn.addEventListener("click", resetGame);

    leaderboard.load();
    leaderboard.render();
    updateScoreDisplay();
    resetGame();
  </script>
</body>
</html>
