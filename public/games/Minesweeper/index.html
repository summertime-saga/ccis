<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minesweeper</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      background: #0c1018;
      color: #e8ecf4;
      font-family: "Courier New", monospace;
    }
    .layout {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(10, 36px);
      grid-template-rows: repeat(10, 36px);
      gap: 4px;
      padding: 6px;
      background: #0f1725;
      border: 1px solid #1f2b3a;
      box-shadow: 0 10px 20px rgba(0,0,0,0.35);
    }
    .cell {
      width: 36px;
      height: 36px;
      background: #1b2a3d;
      border: 1px solid #23354a;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #e8ecf4;
      cursor: pointer;
      user-select: none;
      font-weight: bold;
    }
    .cell.revealed {
      background: #102033;
      border-color: #1f3350;
      cursor: default;
    }
    .cell.mine { background: #ff4b4b; color: #fff; }
    .cell.flag { background: #b23b3b; color: #fff; }
    #info {
      max-width: 240px;
      text-align: left;
      font-size: 14px;
      line-height: 1.5;
      color: #d6deff;
      text-shadow: 0 0 6px rgba(255,255,255,0.2);
    }
    #stats {
      margin-top: 12px;
      padding: 10px;
      border: 1px solid #1f2b3a;
      border-radius: 8px;
      background: #0f1725;
    }
    #stats .row { font-weight: bold; letter-spacing: 0.5px; margin-bottom: 6px; }
    #leaderboard {
      margin-top: 12px;
      padding: 10px;
      border: 1px solid #1f2b3a;
      border-radius: 8px;
      background: #0f1725;
    }
    #leaderboard .label {
      text-transform: uppercase;
      font-size: 11px;
      letter-spacing: 1px;
      color: #9fb0d8;
      margin-bottom: 6px;
    }
    #leaderboard-list { margin: 0; padding-left: 18px; }
    #leaderboard-list li { margin-bottom: 4px; }
    #leaderboard-list li.empty {
      list-style: none;
      padding-left: 0;
      color: #9fb0d8;
    }
    #status { margin-top: 10px; color: #ffd447; min-height: 18px; font-size: 13px; }
    #menu-link {
      display: inline-block;
      margin-top: 12px;
      padding: 8px 12px;
      border-radius: 6px;
      background: #7dd6ff;
      color: #0c111a;
      text-decoration: none;
      font-weight: bold;
      box-shadow: 0 0 10px rgba(125,214,255,0.4);
    }
  </style>
</head>
<body>
  <div class="layout">
    <div id="board"></div>
    <div id="info">
      Left click to reveal. Right click to flag a mine. Empty cells flood fill. Avoid the 10 hidden mines! Refresh to start a new board.<br>
      Project of CCIS students
      <div id="stats">
        <div class="row">Score: <span id="score">0</span></div>
        <div class="row">Best: <span id="best">0</span></div>
      </div>
      <div id="leaderboard">
        <div class="label">Leaderboard</div>
        <ol id="leaderboard-list"></ol>
      </div>
      <div id="status"></div>
    </div>
  </div>

  <script src="../leaderboard.js"></script>
  <script>
    const boardEl = document.getElementById("board");
    const scoreEl = document.getElementById("score");
    const bestEl = document.getElementById("best");
    const leaderboardListEl = document.getElementById("leaderboard-list");
    const statusEl = document.getElementById("status");

    const leaderboard = createLeaderboard({
      storageKey: "minesweeperLeaderboard",
      nameKey: "minesweeperPlayerName",
      listElement: leaderboardListEl
    });
    const size = 10;
    const mines = 10;
    const cells = [];
    let score = 0;
    let gameOver = false;
    let statusTimer = null;

    function updateHud(renderBoard = false) {
      scoreEl.textContent = score;
      bestEl.textContent = leaderboard.format(leaderboard.best());
      if (renderBoard) leaderboard.render();
    }

    function setStatus(message, color = "#ffd447") {
      statusEl.textContent = message;
      statusEl.style.color = color;
      if (statusTimer) clearTimeout(statusTimer);
      statusTimer = setTimeout(() => { statusEl.textContent = ""; }, 2500);
    }

    function recordScore() {
      leaderboard.record(score);
      updateHud(true);
    }

    function init() {
      boardEl.innerHTML = "";
      cells.length = 0;
      score = 0;
      gameOver = false;
      for (let r = 0; r < size; r++) {
        const row = [];
        for (let c = 0; c < size; c++) {
          const div = document.createElement("div");
          div.className = "cell";
          div.dataset.r = r;
          div.dataset.c = c;
          div.addEventListener("click", onReveal);
          div.addEventListener("contextmenu", onFlag);
          boardEl.appendChild(div);
          row.push({ mine: false, revealed: false, flagged: false, n: 0, el: div });
        }
        cells.push(row);
      }
      placeMines();
      calcNumbers();
      updateHud(true);
      setStatus("New board generated", "#7dd6ff");
    }

    function placeMines() {
      let placed = 0;
      while (placed < mines) {
        const r = Math.floor(Math.random() * size);
        const c = Math.floor(Math.random() * size);
        if (!cells[r][c].mine) {
          cells[r][c].mine = true;
          placed++;
        }
      }
    }

    function calcNumbers() {
      const dirs = [-1, 0, 1];
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          if (cells[r][c].mine) continue;
          let count = 0;
          dirs.forEach(dr => dirs.forEach(dc => {
            if (dr === 0 && dc === 0) return;
            const nr = r + dr, nc = c + dc;
            if (nr >= 0 && nr < size && nc >= 0 && nc < size && cells[nr][nc].mine) count++;
          }));
          cells[r][c].n = count;
        }
      }
    }

    function onFlag(e) {
      e.preventDefault();
      if (gameOver) return;
      const cell = getCell(e.currentTarget);
      if (cell.revealed) return;
      cell.flagged = !cell.flagged;
      cell.el.classList.toggle("flag", cell.flagged);
      cell.el.textContent = cell.flagged ? "âš‘" : "";
    }

    function onReveal(e) {
      if (gameOver) return;
      const cell = getCell(e.currentTarget);
      if (cell.revealed || cell.flagged) return;
      revealCell(cell);
      checkWin();
    }

    function revealCell(cell) {
      if (cell.revealed) return;
      cell.revealed = true;
      cell.el.classList.add("revealed");
      if (cell.mine) {
        cell.el.classList.add("mine");
        cell.el.textContent = "ðŸ’£";
        revealAllMines();
        gameOver = true;
        recordScore();
        setStatus("Boom! Score saved to the leaderboard.", "#ff7b7b");
        return;
      }
      score += 1;
      updateHud();
      if (cell.n > 0) {
        cell.el.textContent = cell.n;
      } else {
        flood(cell);
      }
    }

    function flood(start) {
      const q = [start];
      const dirs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
      while (q.length) {
        const cell = q.shift();
        dirs.forEach(([dr, dc]) => {
          const nr = Number(cell.el.dataset.r) + dr;
          const nc = Number(cell.el.dataset.c) + dc;
          if (nr < 0 || nr >= size || nc < 0 || nc >= size) return;
          const nCell = cells[nr][nc];
          if (nCell.revealed || nCell.flagged || nCell.mine) return;
          nCell.revealed = true;
          nCell.el.classList.add("revealed");
          score += 1;
          updateHud();
          if (nCell.n > 0) {
            nCell.el.textContent = nCell.n;
          } else {
            q.push(nCell);
          }
        });
      }
    }

    function revealAllMines() {
      cells.flat().forEach(cell => {
        if (cell.mine) {
          cell.el.classList.add("mine", "revealed");
          cell.el.textContent = "ðŸ’£";
        }
      });
      boardEl.querySelectorAll(".cell").forEach(el => el.removeEventListener("click", onReveal));
    }

    function checkWin() {
      const safeLeft = cells.flat().filter(c => !c.mine && !c.revealed).length;
      if (safeLeft === 0) {
        gameOver = true;
        score = size * size - mines;
        updateHud();
        recordScore();
        setStatus("Board cleared! Score saved to the leaderboard.", "#7dd6ff");
      }
    }

    function getCell(el) {
      const r = Number(el.dataset.r);
      const c = Number(el.dataset.c);
      return cells[r][c];
    }

    leaderboard.load();
    leaderboard.render();
    updateHud(true);
    init();
  </script>
</body>
</html>
